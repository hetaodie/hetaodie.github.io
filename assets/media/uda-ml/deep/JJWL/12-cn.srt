1
00:00:00,000 --> 00:00:04,753
我们现在可以介绍第二种 也是最后一种层级类型了

2
00:00:04,753 --> 00:00:09,693
然后才能构建自己的卷积神经网络

3
00:00:09,694 --> 00:00:15,955
这些所谓的池化层经常将卷积层当做输入

4
00:00:15,955 --> 00:00:18,780
卷积层是指特征映射堆栈

5
00:00:18,780 --> 00:00:22,679
每个过滤器对应一个特征映射

6
00:00:22,678 --> 00:00:24,974
具有很多不同的对象类别的复杂数据集

7
00:00:24,975 --> 00:00:29,684
将需要大量的过滤器

8
00:00:29,684 --> 00:00:33,600
每个过滤器负责从图片中查找一种规律

9
00:00:33,600 --> 00:00:35,923
过滤器越多 则堆栈越大

10
00:00:35,923 --> 00:00:40,769
意味着卷积层的维度可能会很庞大

11
00:00:40,770 --> 00:00:44,429
维度越高 我们就需要使用更多的参数

12
00:00:44,429 --> 00:00:47,039
这样可能会导致过拟合

13
00:00:47,039 --> 00:00:50,935
因此 我们需要一种方法来降低维数

14
00:00:50,935 --> 00:00:54,905
这就是卷积神经网络中的池化层所扮演的角色

15
00:00:54,905 --> 00:00:59,454
我们将侧重于两者不同类型的池化层

16
00:00:59,454 --> 00:01:02,234
第一种类型是最大池化层

17
00:01:02,234 --> 00:01:07,030
最大池化层将一组特征映射作为输入

18
00:01:07,030 --> 00:01:11,415
这里我们放大并可视化了所有三个特征映射

19
00:01:11,415 --> 00:01:13,314
和卷积层一样

20
00:01:13,313 --> 00:01:16,403
我们将定义窗口大小和 stride

21
00:01:16,405 --> 00:01:20,819
这里 窗口大小设为 2 stride 也设为 2

22
00:01:20,819 --> 00:01:23,064
要构建最大池化层

23
00:01:23,063 --> 00:01:26,128
我们将单独处理每个特征映射

24
00:01:26,129 --> 00:01:28,379
先从第一个特征映射开始

25
00:01:28,379 --> 00:01:32,715
从图片的左上角开始移动窗口

26
00:01:32,715 --> 00:01:36,989
最大池化层中对应的节点值计算方法是：

27
00:01:36,989 --> 00:01:42,165
拿出窗口中包含的最大像素

28
00:01:42,165 --> 00:01:45,674
这里 我们的窗口中有像素

29
00:01:45,674 --> 00:01:47,174
1 9 5 和 4

30
00:01:47,174 --> 00:01:50,219
因此最大值是 9

31
00:01:50,218 --> 00:01:54,375
如果针对所有特征映射继续这一流程

32
00:01:54,375 --> 00:01:58,453
则输出是一组具有相同数量的特征映射

33
00:01:58,453 --> 00:02:03,039
但是每个特征映射的宽和高都减小了

34
00:02:03,040 --> 00:02:08,895
这里 宽和高是上一个卷积层的一半

35
00:02:08,895 --> 00:02:11,759
全局平均池化稍微有点不同

36
00:02:11,758 --> 00:02:17,603
对于这种类型的层级 我们既不指定窗口大小 也不指定 stride

37
00:02:17,604 --> 00:02:22,365
这是一种更极端的降低维度的池化类型

38
00:02:22,365 --> 00:02:25,080
它获得一堆特征映射

39
00:02:25,080 --> 00:02:29,310
并计算其中每个映射的节点均值

40
00:02:29,310 --> 00:02:32,128
和之前一样 我们将单独处理每个特征映射

41
00:02:32,127 --> 00:02:36,072
并从第一个特征映射开始

42
00:02:36,074 --> 00:02:42,680
要计算节点的均值 我们首先对所有值求和 结果是 80

43
00:02:42,680 --> 00:02:47,580
然后除以节点总数 16

44
00:02:47,580 --> 00:02:51,930
结果是 5 即这个节点的值

45
00:02:51,930 --> 00:02:56,120
然后对剩下的两个特征映射重复相同的流程

46
00:02:56,120 --> 00:02:58,563
两个值都是 4

47
00:02:58,562 --> 00:03:02,042
最终输出是一堆特征映射

48
00:03:02,044 --> 00:03:06,824
每个特征映射都缩减成一个值

49
00:03:06,824 --> 00:03:08,360
这样我们可以看出

50
00:03:08,360 --> 00:03:14,949
全局平均池化将三维数组变成了向量

51
00:03:14,949 --> 00:03:18,949
这里的向量有三个条目

52
00:03:18,949 --> 00:03:22,819
我们用一盘食物做比喻 对所学的知识进行总结

53
00:03:22,818 --> 00:03:25,568
我们可以将卷积层看做一堆煎饼

54
00:03:25,568 --> 00:03:29,343
每个煎饼表示一个特征映射

55
00:03:29,342 --> 00:03:34,358
池化层获取这堆煎饼 并返回具有相同数量的一堆煎饼

56
00:03:34,360 --> 00:03:39,774
但是输出煎饼的宽和高变小了

57
00:03:39,774 --> 00:03:45,919
非全局池化层表示煎饼大小的适中降低

58
00:03:45,919 --> 00:03:48,759
每个煎饼大概是

59
00:03:48,758 --> 00:03:52,883
对应输入煎饼宽和高的一半

60
00:03:52,883 --> 00:03:59,834
全局池化层相当于将输入煎饼输出后变成了面包屑

61
00:03:59,835 --> 00:04:04,270
但是每个输入煎饼依然对应一个面包屑

62
00:04:04,270 --> 00:04:08,064
在此视频中 我们重点讲解了两种类型的池化

63
00:04:08,062 --> 00:04:14,000
欢迎阅读下方链接的 Keras 文档 了解其他池化类型

