1
00:00:00,000 --> 00:00:02,160
我们已经编译好模型

2
00:00:02,160 --> 00:00:03,995
可以训练模型了

3
00:00:03,995 --> 00:00:07,724
训练步骤和上节课的差不多

4
00:00:07,724 --> 00:00:10,130
要了解修改的地方

5
00:00:10,130 --> 00:00:14,175
我们首先需要知道模型验证这一概念

6
00:00:14,175 --> 00:00:16,379
到目前为止 我们都是根据损失和准确率

7
00:00:16,379 --> 00:00:20,789
随着 epoch 的变化而如何变化来判断模型效果

8
00:00:20,789 --> 00:00:22,605
如果你自己设计了模型

9
00:00:22,605 --> 00:00:25,949
就可能会发现并非始终都清楚网络应该具有多少层级

10
00:00:25,949 --> 00:00:29,839
或每层应该有多少个节点

11
00:00:29,838 --> 00:00:32,429
应该使用多少个 epoch

12
00:00:32,429 --> 00:00:37,780
在设计架构时 需要作出很多决定

13
00:00:37,780 --> 00:00:40,829
实际操作中用到的一种方法是

14
00:00:40,829 --> 00:00:43,963
将数据分成三个类别

15
00:00:43,963 --> 00:00:46,603
分别是训练集 验证集和测试集

16
00:00:46,603 --> 00:00:49,607
模型会单独处理每个数据集

17
00:00:49,609 --> 00:00:54,670
模型在决定如何修改权重时 仅使用训练数据

18
00:00:54,670 --> 00:00:57,475
在每个 epoch 模型通过检查验证集的准确率

19
00:00:57,475 --> 00:01:01,085
来判断模型的效果

20
00:01:01,085 --> 00:01:04,379
但是务必要注意的是

21
00:01:04,379 --> 00:01:09,194
模型不会使用任何验证集进行反向传播

22
00:01:09,194 --> 00:01:13,260
我们使用训练集来查找所有的规律

23
00:01:13,260 --> 00:01:17,834
并用验证集来判断所选模型效果是否不错

24
00:01:17,834 --> 00:01:22,445
因为模型不使用验证集来决定权重

25
00:01:22,444 --> 00:01:26,482
它还可以告诉我们是否对训练集进行了过拟合

26
00:01:26,483 --> 00:01:31,088
例如 假设用模型训练了 200 个 epoch

27
00:01:31,090 --> 00:01:33,000
但是在大约第 100 个 epoch 时

28
00:01:33,000 --> 00:01:35,790
你发现了一些过拟合现象

29
00:01:35,790 --> 00:01:42,180
训练损失开始下降 但是验证损失开始增大

30
00:01:42,180 --> 00:01:45,719
然后你希望保留大概在第 100 个 epoch 的权重

31
00:01:45,718 --> 00:01:49,978
并忽略或放弃后续 epoch 的权重

32
00:01:49,980 --> 00:01:53,219
我们在 notebook 中就是这么操作的

33
00:01:53,218 --> 00:01:56,429
但是如果我们有多个潜在架构可供选择

34
00:01:56,430 --> 00:02:00,180
这种流程也很有用

35
00:02:00,180 --> 00:02:04,409
例如 你要判断模型中应该有多少层

36
00:02:04,409 --> 00:02:06,614
那么你需要保存每个潜在架构的权重

37
00:02:06,614 --> 00:02:09,990
以便后续进行比较

38
00:02:09,990 --> 00:02:15,110
你始终会选择验证损失最低的模型

39
00:02:15,110 --> 00:02:19,905
你可能有疑问 为何必须创建第三个数据集

40
00:02:19,905 --> 00:02:23,340
使用测试集不行吗？

41
00:02:23,340 --> 00:02:26,218
当我们测试模型时

42
00:02:26,217 --> 00:02:29,967
模型会查看完全从未见过的数据

43
00:02:29,967 --> 00:02:34,947
虽然模型不使用验证集来更新权重

44
00:02:34,949 --> 00:02:40,205
但是模型选择流程也会偏向于验证集

45
00:02:40,205 --> 00:02:43,860
因此我们需要三组独立的数据集

46
00:02:43,860 --> 00:02:45,719
回到代码部分

47
00:02:45,717 --> 00:02:51,108
注意 fit 方法将 validation_split 作为参数

48
00:02:51,110 --> 00:02:53,944
在此处 我们将其设为 0.2

49
00:02:53,943 --> 00:02:57,868
即有 20% 原先分配为训练数据的数据

50
00:02:57,870 --> 00:03:04,349
将从数据集中拿出来当做验证集

51
00:03:04,348 --> 00:03:09,868
ModelCheckpoint 类允许我们在每个 epoch 之后保存模型权重

52
00:03:09,870 --> 00:03:15,360
filepath 参数指定了权重的保存位置

53
00:03:15,360 --> 00:03:19,110
通过将 save_best_only 参数设为 True

54
00:03:19,110 --> 00:03:21,479
可以告诉模型仅保存权重

55
00:03:21,479 --> 00:03:26,094
以让验证集达到最佳准确率

56
00:03:26,092 --> 00:03:28,090
将 verbose 设为 1

57
00:03:28,090 --> 00:03:30,824
训练过程中的文本输出将告诉你

58
00:03:30,824 --> 00:03:34,479
权重文件何时更新了

59
00:03:34,479 --> 00:03:36,419
创建此 checkpointer 后

60
00:03:36,419 --> 00:03:42,025
在拟合模型时将其传入为参数 现在该你来操作了

61
00:03:42,025 --> 00:03:46,974
在 Jupyter notebook 中运行该模型 并查看训练输出

62
00:03:46,973 --> 00:03:49,201
应该看到对于大多数 epoch

63
00:03:49,200 --> 00:03:51,810
验证损失都下降了

64
00:03:51,810 --> 00:03:53,430
这表明我们创建了良好的模型

65
00:03:53,430 --> 00:03:58,300
我们将在测试数据集中获得好的效果

66
00:03:58,300 --> 00:04:01,000
我们将在下个视频中看看效果如何

