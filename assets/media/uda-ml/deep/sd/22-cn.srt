1
00:00:00,000 --> 00:00:03,653
可以看出 到目前为止 我们的算法都是值形式

2
00:00:03,653 --> 00:00:05,714
意味着我们需要输入数字

3
00:00:05,714 --> 00:00:08,640
例如测试或评分得分

4
00:00:08,640 --> 00:00:12,570
但是输入数据并非始终都是数字

5
00:00:12,570 --> 00:00:14,115
有时候看起来是这样的

6
00:00:14,115 --> 00:00:15,925
假设该模型的输入是

7
00:00:15,925 --> 00:00:18,640
你是否收到礼物

8
00:00:18,640 --> 00:00:21,710
如何变成数字呢？其实很简单

9
00:00:21,710 --> 00:00:25,044
如果收到礼物 则说输入变量是 1

10
00:00:25,044 --> 00:00:29,019
如果没有收到礼物 则说输入变量是 0

11
00:00:29,018 --> 00:00:30,724
如果有更多类别呢？

12
00:00:30,725 --> 00:00:34,515
和之前一样 假设类别是鸭子 海狸和海象

13
00:00:34,515 --> 00:00:37,670
在算法中输入什么变量呢？

14
00:00:37,670 --> 00:00:39,120
或许可以输入 0 1 和 2

15
00:00:39,118 --> 00:00:42,118
但是这样不可行 这样就假设各个类别之间存在依赖性

16
00:00:42,118 --> 00:00:45,269
实际上不能存在 我们采取的操作是

17
00:00:45,270 --> 00:00:48,850
对每个类别设定一个变量

18
00:00:48,850 --> 00:00:50,700
表格变成这样

19
00:00:50,700 --> 00:00:53,520
鸭子一个变量 海狸一个变量

20
00:00:53,520 --> 00:00:58,109
海象一个变量 每个都有对应的列

21
00:00:58,109 --> 00:01:01,500
如果输入是鸭子 那么鸭子变量就是 1

22
00:01:01,500 --> 00:01:06,385
海狸和海象变量是 0

23
00:01:06,385 --> 00:01:09,224
海狸和海象也一样

24
00:01:09,224 --> 00:01:14,784
数据可能有更多的列 但是至少不存在不需要的依赖性了

25
00:01:14,784 --> 00:01:19,000
这一流程就叫做一位one-hot 编码 经常用来处理数据

