1
00:00:03,060 --> 00:00:08,214
到目前为止 我们已经讨论了离散化连续状态空间的各种方式

2
00:00:08,214 --> 00:00:09,640
这些方式使我们能够几乎不做修改

3
00:00:09,640 --> 00:00:14,065
就能使用现有的强化学习算法

4
00:00:14,064 --> 00:00:16,149
但是也存在一些限制

5
00:00:16,149 --> 00:00:18,759
当底层空间很复杂时

6
00:00:18,760 --> 00:00:22,600
所需的离散状态数量可能会很大

7
00:00:22,600 --> 00:00:25,495
因此就失去了离散化的优势

8
00:00:25,495 --> 00:00:29,980
此外 对于状态空间里临近的位置

9
00:00:29,980 --> 00:00:34,015
它们的值应该相似或者平滑地变化

10
00:00:34,015 --> 00:00:37,582
但是离散化并非始终会利用这一特性

11
00:00:37,582 --> 00:00:41,030
无法跨空间地有效泛化

12
00:00:41,030 --> 00:00:45,620
我们要获得的是真实的状态值函数 vπ

13
00:00:45,619 --> 00:00:48,259
或动作值函数 qπ

14
00:00:48,259 --> 00:00:52,534
通常在整个空间内都比较平滑连续

15
00:00:52,534 --> 00:00:53,959
可以想象

16
00:00:53,960 --> 00:00:59,810
除了一些非常简单的问题之外 完全捕获这种特性几乎不可行

17
00:00:59,810 --> 00:01:02,554
我们的最佳希望是函数逼近

18
00:01:02,554 --> 00:01:07,819
依然是逼近结果 因为我们不知道真正的底层函数是什么

19
00:01:07,819 --> 00:01:11,419
定义此类函数逼近的一般方法是

20
00:01:11,420 --> 00:01:15,379
引入一个表示函数形状的参数向量 W

21
00:01:15,379 --> 00:01:17,750
我们的任务变成调整这个参数向量

22
00:01:17,750 --> 00:01:21,665
直到找到理想的逼近结果

23
00:01:21,665 --> 00:01:25,910
注意逼近函数可以将状态映射到其值

24
00:01:25,909 --> 00:01:29,359
或将状态动作对映射到相应的 q 值

25
00:01:29,359 --> 00:01:34,265
另一种形式是从一个状态映射到一堆不同的 q 值

26
00:01:34,265 --> 00:01:36,859
同时映射到每个动作

27
00:01:36,859 --> 00:01:40,700
这对 Q 学习来说尤其实用 稍后我们会讲解

28
00:01:40,700 --> 00:01:42,769
先来看看第一种情况

29
00:01:42,769 --> 00:01:45,334
逼近状态值函数

30
00:01:45,334 --> 00:01:50,149
中间的方框应该会完成处理流程

31
00:01:50,150 --> 00:01:52,100
将状态 S 和参数 W

32
00:01:52,099 --> 00:01:55,759
转换为标量值

33
00:01:55,760 --> 00:01:58,835
但是如何转换呢？

34
00:01:58,834 --> 00:02:02,134
首先我们需要确保有一个表示状态的向量

35
00:02:02,135 --> 00:02:06,740
你的状态可能已经是一个向量 这样的话 你不需要进行任何处理

36
00:02:06,739 --> 00:02:11,314
通常 我们将定义一个转换算法

37
00:02:11,314 --> 00:02:16,055
将任何给定状态 S 转换为特征向量 X(s) 这样也给我们带来了更多的灵活性

38
00:02:16,055 --> 00:02:19,145
因为我们不需要对原始状态值进行运算

39
00:02:19,145 --> 00:02:22,680
我们可以改为使用任何计算或推导的特征

40
00:02:22,680 --> 00:02:25,870
现在我们已经有了

41
00:02:25,870 --> 00:02:27,594
特征向量 X(s) 和参数向量 W

42
00:02:27,594 --> 00:02:29,995
我们想要获得一个标量值

43
00:02:29,995 --> 00:02:33,039
如果我们有两个向量并想要生成标量

44
00:02:33,039 --> 00:02:35,057
该怎么办？

45
00:02:35,057 --> 00:02:38,784
进行点积运算 没错 这是最简单的方式

46
00:02:38,784 --> 00:02:43,914
实际上 这和计算特征的线性组合一样

47
00:02:43,914 --> 00:02:48,294
将每个特征与相应的权重相乘 然后求和

48
00:02:48,294 --> 00:02:51,399
称之为线性函数逼近

49
00:02:51,400 --> 00:02:53,439
即我们尝试使用线性函数

50
00:02:53,439 --> 00:02:56,530
逼近底层值函数

