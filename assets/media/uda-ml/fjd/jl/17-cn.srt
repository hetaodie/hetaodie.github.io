1
00:00:00,100 --> 00:00:02,840
现在 我将向你展示另一个效果并不完美的数据集

2
00:00:02,840 --> 00:00:06,580
你可以了解 k-均值 聚类是如何保持不变的

3
00:00:06,580 --> 00:00:10,100
我将在该示例中使用的数据类型为均匀分布

4
00:00:10,100 --> 00:00:11,690
这是均匀分布的样子

5
00:00:11,690 --> 00:00:13,430
这些点四处分布

6
00:00:13,430 --> 00:00:16,810
看到这些点 我不会说 这儿有我要选择的明确聚类

7
00:00:16,810 --> 00:00:21,000
但我仍希望这样描述

8
00:00:21,000 --> 00:00:24,700
这里的这些点比那里的那些点彼此更为相似

9
00:00:24,700 --> 00:00:28,430
k-means 聚类方法是可用于从数学方面

10
00:00:28,430 --> 00:00:29,710
描述数据呈现出该现象的方法之一

11
00:00:29,710 --> 00:00:33,660
我并不能仅凭理论就确定我要在此使用的矩心的数量

12
00:00:33,660 --> 00:00:35,400
所以我只使用两个

13
00:00:35,400 --> 00:00:37,200
这个数字还算合理

14
00:00:37,200 --> 00:00:38,040
一 二

15
00:00:38,040 --> 00:00:40,390
然后 我们来了解一下在该案例中会出现什么情况

16
00:00:40,390 --> 00:00:41,950
很少的点需要重新分配

17
00:00:41,950 --> 00:00:42,740
移动矩心

18
00:00:42,740 --> 00:00:46,780
你会看到此处需要进行更多微调

19
00:00:46,780 --> 00:00:52,560
但最终基本上都是沿着该轴分割数据

20
00:00:52,560 --> 00:00:56,930
如果你再次尝试 根据确定的初始状况和

21
00:00:56,930 --> 00:00:59,470
这些点分配方式的详情

22
00:00:59,470 --> 00:01:02,080
我会得到略有不同的结果

23
00:01:02,080 --> 00:01:02,980
你也看到了

24
00:01:02,980 --> 00:01:05,519
我最终是垂直而不是水平分割这些数据

25
00:01:05,519 --> 00:01:08,360
对此 你的想法应该是 矩心初始放置的位置通常比较随机

26
00:01:08,360 --> 00:01:13,360
而且非常重要

27
00:01:13,360 --> 00:01:16,410
因此根据某一确定的初始状况

28
00:01:16,410 --> 00:01:20,770
你最终可以使聚类的结果看起来完全不同

29
00:01:20,770 --> 00:01:22,750
现在 这看起来可能是一个比较严重的问题

30
00:01:22,750 --> 00:01:26,150
但我们有一种相当强大的方法将其解决

31
00:01:26,150 --> 00:01:27,020
接下来我们讨论一下该方法

