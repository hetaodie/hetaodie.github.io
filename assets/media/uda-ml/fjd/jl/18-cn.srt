1
00:00:00,160 --> 00:00:03,230
我已经向你介绍了 k-均值 聚类方法的理论知识

2
00:00:03,230 --> 00:00:07,500
现在 我将向你展示如何使用 scikit-learn 的实现

3
00:00:07,500 --> 00:00:08,780
将它部署到你自己的研究中

4
00:00:08,780 --> 00:00:10,340
我先通过 Google 搜索开始

5
00:00:10,340 --> 00:00:13,810
发现有关 scikit-learn 聚类方法的内容有一整页

6
00:00:13,810 --> 00:00:15,890
进入该页面后 我首先注意到

7
00:00:15,890 --> 00:00:20,020
除了 k-均值 聚类外 还有许多类型的聚类

8
00:00:20,020 --> 00:00:23,510
此处所有不同的列都是不同类型的聚类

9
00:00:23,510 --> 00:00:27,720
我们不用全都了解 而只是使用该页面导航至 k-均值 文档

10
00:00:27,720 --> 00:00:30,620
从而使你能够更好地

11
00:00:30,620 --> 00:00:32,509
了解 scikit-learn 的处理方法

12
00:00:32,509 --> 00:00:35,540
此为我拥有的所有不同聚类方法的列表

13
00:00:35,540 --> 00:00:39,320
在这里 列表的第一项就是 k-均值

14
00:00:39,320 --> 00:00:41,350
以及某些有关该算法的摘要信息

15
00:00:41,350 --> 00:00:43,725
你要针对 k-均值 定义的参数之一就是

16
00:00:43,725 --> 00:00:45,760
聚类的数量

17
00:00:45,760 --> 00:00:50,330
请注意 我们必须在一开始就表明要查找的聚类数

18
00:00:50,330 --> 00:00:53,225
确定要尝试的聚类数是

19
00:00:53,225 --> 00:00:55,870
使用 k-均值 时最具挑战的工作之一

20
00:00:57,170 --> 00:01:00,220
然后他会向我们提供一些有关可扩展性的信息

21
00:01:00,220 --> 00:01:02,700
这大体上会告诉我们 当开始拥有大量数据或聚类时

22
00:01:02,700 --> 00:01:04,928
该算法是如何运行的

23
00:01:04,928 --> 00:01:08,390
使用案例为我们提供些许信息

24
00:01:08,390 --> 00:01:11,710
比如当你的聚类中点的数量比较平均时

25
00:01:11,710 --> 00:01:13,510
这有利于用于一般用途等

26
00:01:13,510 --> 00:01:16,660
最后 k-均值 聚类的工作原理是基于

27
00:01:16,660 --> 00:01:18,480
各点之间的距离

28
00:01:18,480 --> 00:01:21,720
与我们迄今为止看到的内容都很协调

29
00:01:21,720 --> 00:01:23,320
我们再深入一点

30
00:01:23,320 --> 00:01:25,790
现在 我们是在 k-均值 文档页面上

31
00:01:25,790 --> 00:01:28,460
有三个参数我希望你能够

32
00:01:28,460 --> 00:01:29,470
特别重视

33
00:01:29,470 --> 00:01:32,410
第一个 也是最重要的一个是 n_clusters

34
00:01:32,410 --> 00:01:35,270
n_clusters 的默认值是 8

35
00:01:35,270 --> 00:01:38,970
当然 大家都知道算法中的聚类数量是

36
00:01:38,970 --> 00:01:42,790
你根据实际的情况自行设置的值

37
00:01:42,790 --> 00:01:45,260
它甚至可能需要你反复调整

38
00:01:45,260 --> 00:01:47,560
所以 你应该随时考虑是否真的想要使用该默认值

39
00:01:47,560 --> 00:01:50,910
或者是否要将其更改为其他值

40
00:01:50,910 --> 00:01:53,170
我向你保证 你大部分情况下都想将其

41
00:01:53,170 --> 00:01:54,320
更改为其他值

42
00:01:54,320 --> 00:01:57,990
我希望你注意的第二个参数是 max_iter=300

43
00:01:57,990 --> 00:02:01,620
请注意 当我们运行 k-均值 聚类时

44
00:02:01,620 --> 00:02:05,320
我们要在查找聚类时进行迭代

45
00:02:05,320 --> 00:02:10,500
将各个点分配到矩心 然后移动矩心

46
00:02:10,500 --> 00:02:12,090
然后重新分配这些点

47
00:02:12,090 --> 00:02:13,770
重新移动矩心

48
00:02:13,770 --> 00:02:17,020
每一次进行分配和移动

49
00:02:17,020 --> 00:02:20,078
分配和移动的步骤就是对算法的迭代

50
00:02:20,078 --> 00:02:23,660
max_iter 其实就是表明你希望进行

51
00:02:23,660 --> 00:02:25,995
多少次算法迭代

52
00:02:25,995 --> 00:02:29,440
300 对你来说通常是比较合理的值

53
00:02:29,440 --> 00:02:32,120
实际上 我想大部分情况下

54
00:02:32,120 --> 00:02:35,700
算法都会在达到最大值前就已经终结了

55
00:02:35,700 --> 00:02:38,690
但如果你希望更好地控制算法以及

56
00:02:38,690 --> 00:02:41,680
迭代流程执行的次数

57
00:02:41,680 --> 00:02:42,520
这正是你需要的参数

58
00:02:42,520 --> 00:02:45,280
我要提到的最后一个参数是

59
00:02:45,280 --> 00:02:46,840
另一个参数 但非常重要

60
00:02:46,840 --> 00:02:50,240
那就是你提供的不同初始化的数量

61
00:02:50,240 --> 00:02:53,240
还记得我们说过 k-均值 聚类有一个挑战

62
00:02:53,240 --> 00:02:55,800
就是完全取决于初始状况

63
00:02:55,800 --> 00:02:58,220
你有时最终会得到不同的聚类结果

64
00:02:58,220 --> 00:03:01,320
然后你需要多次重复该算法

65
00:03:01,320 --> 00:03:05,250
这样 即使任意这些聚类可能都不对 但总的来说

66
00:03:05,250 --> 00:03:08,850
所有聚类的集合总会有满足你要求的聚类

67
00:03:08,850 --> 00:03:10,320
这就是该参数控制的对象

68
00:03:10,320 --> 00:03:13,470
基本上就是控制算法初始化的次数

69
00:03:13,470 --> 00:03:16,320
提出聚类的次数

70
00:03:16,320 --> 00:03:19,360
你会发现默认情况下是进行十次

71
00:03:19,360 --> 00:03:23,750
如果你出于某种原因认为你的聚类可能

72
00:03:23,750 --> 00:03:25,050
特别容易出现糟糕或艰难的初始化过程

73
00:03:25,050 --> 00:03:29,910
那么你需要改的参数就在这里

74
00:03:29,910 --> 00:03:33,570
可能你需要将初始化次数提高一些

75
00:03:33,570 --> 00:03:36,400
但再次强调一遍 在所有这些参数中

76
00:03:36,400 --> 00:03:39,580
聚类数量是绝对最为重要的参数

77
00:03:39,580 --> 00:03:41,610
你应该认真对待

78
00:03:41,610 --> 00:03:43,570
并反复测试后再决定

