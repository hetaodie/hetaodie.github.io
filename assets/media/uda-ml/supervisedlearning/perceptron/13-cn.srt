1
00:00:00,000 --> 00:00:04,915
现在我们已经掌握了用于描述感知器算法的所有工具

2
00:00:04,915 --> 00:00:08,868
从一个带有随机初始参数的方程开始 它定义了一条直线及其划分出的两个区域

3
00:00:08,868 --> 00:00:11,163
也就是正区域和负区域

4
00:00:11,163 --> 00:00:15,044
我们通过不断移动该直线 使分类的结果更准确

5
00:00:15,044 --> 00:00:17,332
而后查看所有的点的分类状态

6
00:00:17,332 --> 00:00:21,094
四个正确分类的点表示 “我被正确分类了”

7
00:00:21,094 --> 00:00:25,379
两个分类不正确的点表示 “靠近点”

8
00:00:25,379 --> 00:00:27,839
我们看看右侧的这个点

9
00:00:27,838 --> 00:00:31,849
并应用前面介绍的方法 让直线靠近该点

10
00:00:31,850 --> 00:00:34,335
经过这样的移动后 这个点被正确分类了

11
00:00:34,335 --> 00:00:36,853
现在看看左侧的这个点

12
00:00:36,853 --> 00:00:38,493
该点表示 “靠近点”

13
00:00:38,493 --> 00:00:41,793
利用前面的方法 现在直线离它更近了

14
00:00:41,795 --> 00:00:45,585
实际上直线移动到了该点的另一侧 分类正确

15
00:00:45,585 --> 00:00:48,298
现在所有点都正确分类 满足条件了

16
00:00:48,298 --> 00:00:52,700
我们写出这个感知器算法的伪代码

17
00:00:52,700 --> 00:00:53,780
从随机权重开始

18
00:00:53,780 --> 00:00:56,259
w1 一直到 wn 和 b

19
00:00:56,259 --> 00:00:58,685
得到线性方程 Wx + b

20
00:00:58,685 --> 00:01:02,079
直线和正负区域

21
00:01:02,079 --> 00:01:07,430
对于坐标从 x1 到 xn 的所有分类错误点 我们执行以下操作

22
00:01:07,430 --> 00:01:12,829
如果预测为 0 意味着该点应该在正区域 而被错分到了负区域

23
00:01:12,828 --> 00:01:15,463
那么权重按以下方法更新

24
00:01:15,465 --> 00:01:21,055
对于 i = 1 到 n 我们将 wi 更改为 wi 加上 α 乘以 xi

25
00:01:21,055 --> 00:01:23,120
α 是学习率

26
00:01:23,120 --> 00:01:26,060
这里 我们使用 0.1

27
00:01:26,060 --> 00:01:30,474
有时候我们也使用 0.01 等 这取决于具体情况

28
00:01:30,474 --> 00:01:33,834
然后将偏置更新为 b + α

29
00:01:33,834 --> 00:01:37,799
这样使直线更加靠近这个分类错误的点

30
00:01:37,799 --> 00:01:41,319
如果预测为 1 也就是负区域的点被错分到了正区域

31
00:01:41,319 --> 00:01:44,640
我们将按照类似的方式更新权重

32
00:01:44,640 --> 00:01:47,189
只不过这一次是相减 而不是相加

33
00:01:47,188 --> 00:01:49,403
对于 i = 1

34
00:01:49,405 --> 00:01:57,875
将 wi 更改为 wi 减去 α*xi 并将偏置单元 b 更改为 b - α

35
00:01:57,875 --> 00:02:02,313
现在直线离分类错误的点更近了

36
00:02:02,313 --> 00:02:05,308
我们重复这一步骤 直到没有被错误分类的点

37
00:02:05,310 --> 00:02:08,562
或达到一个非常小的错误点的个数

38
00:02:08,562 --> 00:02:11,507
或更为直接一些 执行上述步骤 1000 遍 然后停止

39
00:02:11,508 --> 00:02:14,000
稍后我们将看看有哪些选择

