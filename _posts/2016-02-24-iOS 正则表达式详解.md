---
layout: post
title: iOS 正则表达式详解
description: 本文详细讲解了iOS 正则表达式的详细用法
categories: [iOS]
tags: [iOS, 正则表达式]
---


**目录**

* 目录
 {:toc  }

# 正则表达式语法

## 值表达

{% highlight ruby %}

`\`    将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，“n”匹配字符“n”。“\n”匹配换行符。序列“\\”匹配“\”，“\(”匹配“(”。

`.`    匹配除换行符外的任意字符

`\w `  匹配字母或者数字的字符

`\W`   匹配任意不是字母或数字的字符

`\s`    匹配任意的空白符(空格、制表符、换行符)

`\S`    匹配任意不是空白符的字符

`\d `   匹配任意数字

`\D`    匹配任意非数字的字符

`\b`    匹配单词的结尾或者开头的字符

`\B `   匹配任意不是单词结尾或开头的字符

`[^x]`  匹配任意非x的字符。如[^[a-z]]匹配非小写字母的任意字符

`^`      匹配字符串的开头

$      匹配字符串的结尾

{% endhighlight %}

## 修饰表达

{% highlight ruby %}

 `*`    零次或多次匹配前面的字符或子表达式。例如，zo* 匹配“z”和“zoo”。* 等效于 {0,}。

 `+`    一次或多次匹配前面的字符或子表达式。例如，“zo+”与“zo”和“zoo”匹配，但与“z”不匹配。+ 等效于 {1,}。

`? `     零次或一次匹配前面的字符或子表达式。例如，“do(es)?”匹配“do”或“does”中的“do”。? 等效于 {0,1}。

`{n}`    n 是非负整数。正好匹配 n 次。例如，“o{2}”与“Bob”中的“o”不匹配，但与“food”中的两个“o”匹配。

`{n,}`  n 是非负整数。至少匹配 n 次。例如，“o{2,}”不匹配“Bob”中的“o”，而匹配“foooood”中的所有 o。“o{1,}”等效于“o+”。“o{0,}”等效于“o*”。

`{n,m}` 其中 n <= m。匹配至少 n 次，至多 m 次。例如，“o{1,3}”匹配“fooooood”中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。
?

`x|y` 匹配 x 或 y。例如，'z|food' 匹配“z”或“food”。'(z|f)ood' 匹配“zood”或“food”。

`[xyz]` 字符集。匹配包含的任一字符。例如，“[abc]”匹配“plain”中的“a”。

`[^xyz]` 反向字符集。匹配未包含的任何字符。例如，“[^abc]”匹配“plain”中的“p”。

`[a-z]` 字符范围。匹配指定范围内的任何字符。例如，“[a-z]”匹配“a”到“z”范围内的任何小写字母。

`[^a-z]` 反向范围字符。匹配不在指定的范围内的任何字符。例如，“[^a-z]”匹配任何不在“a”到“z”范围内的任何字符。

{% endhighlight %}


# NSPredicate 的简单使用

## 创建NSPredicate

{% highlight ruby %}


NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name == 'Herbie'"];

{% endhighlight %}

我们使用 NSPredicate 的类方法 +predicateWithFormat: 创建了一个 NSPredicate 的对象，并传入了一个字符串参数，这个类方法使用该字符串在后台构建对象，来计算谓词的值，简单来说，就是以这个字符串来当筛选过滤的条件。<br />

## 计算谓词

{% highlight ruby %}

BOOL match = [predicate evaluateWithObject:car];
NSLog(@"%s", (match) ? "YES" : "NO");

{% endhighlight %}

方法 -evaluateWithObject: 通知接收对象（即谓词）根据指定的对象计算自身的值。这里是以 name 作为键路径，使用 `-valueForKeyPath:` 方法来获取名称，然后将自身的这个名称（即 name）与 Herbie 进行比较，相同返回 YES，否则返回 NO。<br />

以下是另外一个谓词：

{% highlight ruby %}

predicate = [NSPredicate predicateWithFormat:@"engine.horsepower > 150"];
match = [predicate evaluateWithObject:car];
NSLog(@"%s", (match) ? "YES" : "NO");

{% endhighlight %}

这个谓词字符串的左侧是一个键路径，该键路径链接到 car 内部，查找 engine，然后再查找 engine 的 horsepower，然后将其与150进行比较，看它是否大于150。<br />


## 数据过滤器

`-filteredArrayUsingPredicate:`，这个方法是 NSArray 数组中的一种类别方法，它会循环遍历数组中的对象，根据谓词来计算每个对象的值，如果是 YES，那么就将这个对象添加到将被返回的新数组中

{% highlight ruby %}

NSArray *results = [cars filteredArrayUsingPredicate:predicate];
NSLog(@"%@", results);

{% endhighlight %}

这样的话，只需要一行代码就可以获取筛选之后的结果了，不过这里输出的是汽车的全部信息，而不是上面那样输出汽车的名字，不过我们可以使用 KVC（键值编码）来提取其中的名称：

{% highlight ruby %}

NSArray *names = [results valueForKey:@"name"];
NSLog(@"%@", names);

{% endhighlight %}

上面的 cars 是不可变数组，如果我们的数据是存放在可变数组里面，而且我们需要剔除不满足条件的对象的话，可以使用 NSMutableArray 的 `-filterUsingPredicate:` 方法：

{% highlight ruby %}

NSMutableArray *carsCopy = [cars mutableCopy];
[carsCopy filterUsingPredicate:predicate];
NSLog(@"%@", carsCopy);

{% endhighlight %}

因为 `NSMutableArray` 是 `NSArray` 的子类，所以也是可以用 `-filteredArrayUsingPredicate:` 方法来构建新的不可变数组的。使用谓词的确很便捷，但是它的运行速度并不会比自己编写全部代码要快，因为它无法避免要使用循环来遍历。

## 格式说明符

从方法 -predicateWithFormat: 可以看出来，传入的字符串是可以使用格式说明符的，比如：%d、%f 等。而且一般筛选条件都不是硬编码到项目里面的，都是根据用户的输入来进行筛选的。

除了可以使用 printf 说明符，还可以使用 %@ 来插入字符串，而 %@ 会被当做带引号的字符串：


{% highlight ruby %}
{% endhighlight %}

<br />

